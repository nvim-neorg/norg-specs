@document.meta
title: 1.0-semantics
description: 
authors: vhyrro
categories: 
created: 2022-09-10
version: 0.0.13
@end

- ( ) Document stdlib macros/carryover tags/ranged tags
- ( ) Describe how tags are evaluated
- ( ) Document inbuilt attached modifier extensions and their behaviours
- ( ) When evaluating macros for attributes (inline elements w/ attached mod ext) and
      the `&var&` syntax they should be placed on a new line and /then/ expanded.
      This prevents user error.
- ( ) Explain how extendable links are macros under the hood.

Table syntax:
- ( ) New motions: `>`, `v`, `^`, `<`
- ( ) Floor motion (go fully left and down): `_`
- ( ) Ceiling motion (go fully up and right): `/`
- ( ) Root of table (A1): `.`
- ( ) Allow the combination of motions with numerical values (`13>`/`2_`)
- ( ) Allow underflowing via `<` (B1 -> A3 if A has 3 occupied cells)
- ::
  Example:
@code norg
  : . : Char
  : > : Name/Type
  : > : Categories
  : _ : `*`
  : > : Headings
  : > : structural, nestable
  : _ : `-`

  : . : Char
  : v : `*`
  : v : `-`
  : v :
  : / : Name/Type
  : v : Headings
  @end
  ---

* Introduction

  This file contains a formal description of the semantics of the Norg file format. For an
  introduction of what the Norg file format is, it is recommended that you read the [specification]
  first. When writing a syntax parser, it's not necessary for you to understand exactly how Norg is
  intended to behave - however, when writing a more sophisticated tool like
  [Neorg]{https://github.com/nvim-neorg/neorg}, understanding how various tags and dynamic elements
  behave is quite crucial.

  This specification, in contrast to the syntax specification, reads more like a book, with
  recommendations and requirements written out as they are applicable.

* Tags

  All dynamic/extendable parts of Norg are centered around tags and macros.
  The single {# macro tag} defines macros, and all of the other tag types
  execute a macro in some specific way.

** Common Definitions

   $ Macro Expansion
   The process of expanding a macro involves supplying it with the correct parameters,
   then replacing the macro invocation with the result, expanding any other macros that
   may be present in said result.

   $ Variable
   A variable is a macro that takes no parameters as input and always produces the same output
   regardless of context.

** Macro Tag

   The base form, the [macro tag]{:1.0-specification:*** Macro Tags} can be seen as a function
   definition - it defines the name of the macro, its parameters, and also what the macro evaluates
   to.
   
   An example implementation of a macro may look like such:
   |example
   =greet name
   Hello, &name&!
   =end
   |end
   
   We define a macro called `greet`, which takes in a mandatory parameter called `name`.
   When this macro is invoked, it evaluates to `Hello, &name&!`
   where the `&name&` variable is replaced with whatever we provided to the macro (see: {# macro
   expansion}, {# inline macro expansion}).
   
*** Macro Redefinitions

    Redefining a macro is permitted. One may have many reasons to redefine macros, it is most
    notably used however when redefining {$ variable}s (see {# parameters as macros}).

*** Parameters as Macros

    Since {$ variable}s are officially just macros without parameters, parameters supplied to
    macros are also themselves macros (hence they can be expanded with the `&inline macro
    expansion&` syntax).

*** Supplying Parameters to Macros

    By default, every parameter that a macro expects must be supplied, else an error should be
    thrown. If excess values are supplied, then the supplied parameters should be highlighted
    in some form in your editor or interpreter and a warning should be issued. Upon execution
    excess values should be discarded.

*** Parameter Modifiers (suffixes)

    There are three suffixes that may be applied to a macro to express some properties about the
    object. These are: `?` (optional variable), `*` (optional vararg), `+` (vararg with at least one
    element).

    To illustrate via an example:

    |example
    =mymacro variable?
    Where did my &variable& go.
    =end
    |end

    Now, it is possible to not supply the variable and not get an error. When expanding a "null"
    object, it should evaluate to an empty string, or in other words, to nothing.

    NOTE: Norg does not actually have a notion of null values. Instead, the null value is
    represented as an empty {* abstract objects}[abstract object]. See that section for more
    details.

    For the vararg variations, they exist to store an arbitrary amount of parameters within a single
    value, which may be thought of as a list of objects. Yet again, Norg does not have a notion of
    lists in their traditional sense, it simply encodes the list as a macro that, when expanded,
    evaluates to the contents of the list (space separated). For example:

    |example
    =vararg.expand args+
    Here are my args: &args&
    =end
    |end

    Given the input `test-arg1 test-arg2` the macro will evaluate to `Here are my args: test-arg1
    test-arg2`.

*** Macro Return Values

    Macros may return only one of three values:
    - Raw Norg Markup
    - An {# Abstract Objects}[abstract object]
    - An abstract object future

    When dealing with raw norg macros, one may only return raw norg markup.
    When invoking {* janet} from within the macro via {* the `eval` carryover tag},
    then the return value is determined by the last expression in the eval block.

    If the return value is not a {https://janet-lang.org/docs/strings.html}[long-string literal]
    (strings delimited with backticks), a `(neorg/abstract-object)` nor
    a `(neorg/await-abstract-object)`, then an appropriate error should be raised.

** Ranged Tags

* Inline Macro Expansion

  Inline macro expansion is the process of expanding the content of a macro in-line via the
  `&` attached modifiers.
  There is no way to supply parameters to an inline macro expansion and, therefore by definition,
  only {# variable}s may be expanded through this syntax.

  When performing inline expansion, first the expansion must be isolated onto its own separate line,
  this involves prefixing and postfixing the inline macro expansion with newlines. This means that
  given the input `Hello, &name&!` (like in our [greet example]{# macro tag}), the macro should be
  isolated like this:

  @code norg

  Hello,
  &name&
  !

  @end

  And only then should `&name&` be expanded to its underlying value.

  Such a rule allows these variables to expand to complex data types like headings, footnotes and
  other detached modifiers without unintentionally breaking.

* Extendable Links

* The `#eval` Carryover Tag

* The Standard Library

* Abstract Objects

  Abstract Objects (AOs) are an opaque data type within Norg. They serve as a way to represent some
  intermediate information about an object without having concrete Norg markup backing it.

  Abstract Objects have a few builtin properties - some must be provided, whereas others are left as
  optional:
  - The {# AST Node} that the abstract object would like to bind itself to (*optional*)
  - A translation function to convert the intermediate representation of the AO to any given target
    format (markdown, asciidoc etc.). The target may also be Norg itself. Returning `nil` tells
    Neorg that said object does not have a representation for the given target. (*required*)
  - Custom data that the AO would like to keep for future reference (*optional*)

  A prime example of AOs in use are `@code` blocks. There is no Norg syntax that `@code` blocks
  could possibly evaluate to, as Norg does not have a built-in code block syntax. Instead,
  when the `@code` macro is evaluated, it gets translated into an abstract object with some
  properties. Now, when the user wants to export their Norg document into markdown, the translation
  function is invoked, and the `@code` block is converted into a markdown fenced code block
  (`|```|`).

** "Null" Objects

   Null objects are a special type of AO, which form when the {# AST Node} is left as
   `nil`, and whose translation function simply always return an empty string (`""`).

   To produce a null AO, you may use the `(neorg/null-abstract-object)` function (see {* janet}[this
   section] on janet support).

** `&...&` expansion overrides

* Janet

** AST Nodes

  ===

%| vim: set tw=100 :|%
